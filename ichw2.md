# 作业2

## 1. Turing Machine

###  a. 图灵为何要证明停机问题？

   **Answer**：  该缘由可从一个数学问题说起，在上世纪1900年巴黎的国际数学大会上，形式主义学派的数学家希尔伯特提出了23个具有挑战性的课题，其中第二个课题讲述了算数公理的无矛盾性，认为在一个体系中所有的命题都可以证明或证伪。但后来，哥德尔不完备性定理直接击碎了希尔伯特的命题。图灵为了解决希尔伯特的问题，从图灵机的角度出发，设计了如此的计算模型来证明，在一个体系中，必定存在命题无法证明或证伪。

###  b. 图灵的证明方法是？

    Answer：这个证明是在一种理想的情况下出现的：

    首先我们假定存在一个万能的程序H(),他能判断一个程序在输入的时候能否停机；

    之后我们再建造一个程序P(),对P进行编写，

    当H()能够判断一个程序停机时，则P()陷入循环；
 
    当H()不能判断一个程序停机时，则P()停机。
   
    即，P（）与H（）的输出恰好相反。

    此时，由于P（）也是一个程序，我们用P（）调用P（），得到P（P）

    那么，如果P能够停机，那么根据H的判断，它会陷入循环；

    如果P不能停机陷入循环，那么他会停机。
   
    这样便得出矛盾，即P的判断与自身相悖，该问题得到证明。

###   c. 该证明的数学原理

**Answer**：该证明的数学原理是由康纳尔提出的**对角线方法**。对角线方法证明了有理数域的不完备性，而图灵的停机问题则采用类似的方法，利用了图灵机的可数性类比有理数，因此并构建新的图灵机，但无论怎样构建，都无法摆脱该程序属于图灵机的事实，因此最终得出了矛盾。

## 2. 二进制补码的原理

**Answer**：

#### a. 什么是补码？

补码与原码、反码相同，都是二进制数的一种表现形式。

**原码**  指的是在一个二进制的真值前加一位符号位，第一位为符号位（0为正，1为负），后面的为数值。

    如：-2=1000 0010  2=0000 0010

**反码**  指的是在原码的基础上，负数的原码除符号位外其余各位取反，正数的反码就是原码。
 
    如：-2=1111 1101  2=0000 0010

**补码**  则是对反码的延伸，正数的补码与原码相同，负数的补码是在反码的基础上加一。

    如：-2=1111 1110  2=0000 0010 

#### b. 为什么要引入补码？

  在计算机中，数据都是以二进制的形式储存的，那么当涉及到数据的运算时，为了简化设计，计算机往往会将两个数的数码直接计算，而原码和反码都不能满足这样运算的要求。因为对于负数的运算存在符号，而带有符号的原码与补码的运算是不准确甚至是错误的。

比如：

原码：

    1 - 1 = 1 + (-1) = 0000 0001 + 1000 0001 = 1000 0010 = -2

反码：

    1 - 1 = 1 + (-1) = 0000 0001 + 1111 1110 = 1111 1111 = 1000 0000（原码） = -0

  可见在反码中存在两个0，+0和-0。为了解决这个问题，引入了补码。

补码：

    1-1 = 1 + (-1) = 0000 0001 + 1111 1111 = 0000 0000 = 0

即对于补码来说，任意两个数相加都等于两个数的补码相加（对于减法，相当于加一个数的负数，因此计算机中仅存在加法），同时又避免了出现两个0的弊端。

#### c. 为什么补码可以直接计算？它的原理是什么？

    补码的数学原理为 同模 和 取余 .

    对于任意两个数a、b，若a=b(mod m),c=d(mod m)

    那么，a+b=c+d (mod m) (mod 为取模，即一个数整除m后的余数)

    对于负数的取模即

    x mod y = x - y*[x/y]

对于反码来说其实相当于对 x111 1111 取模，因此反码是可以运算的，但是存在两个0，因此为了使其中一个0消失，认为的加大模长，即在反码上加 1（相当于对1000 0000取模），这就成为了补码，所以说补码是可以运算的，同时只有一个0.

我们用更简单的方式来理解，对于补码来说，负数取模的过程类似于钟表。钟表可以看做十二进制的计数方式，在表盘上：

**-2 = 10**

    比如，现在表盘上为3点，我们想要把它调成10点，可以采用几种方式
    1. 顺时针调7个刻度；（3+7=10）
    2. 逆时针调5个刻度；（3-5=-2=10[mod 12]）
    
而补码与之是一个道理，不过，补码（以8位为例）所用的“钟表”的刻度以128为一个周期，-1=127，而在128为周期中所有取模的数都小于128，因此正数取模后仍未它自身（对应正数的补码为自身），负数取模就相当于用128与之相加（对应除符号位之外全都取反再加一，实际上就是二进制中与1000 0000相加），而根据上述数学原理，两个数相加减的模与它们的模相加减的值相等，最终就得到了补码的运算法则。 



## 3. IEEE 754（16 bit） 浮点数表示（8个小数位）

|Sign|Exp|Frac|Value|
|:-----:|:-----:|:-----:|:-----:|
| * |000 0000|0000 0000|±0|
| 0 |011 1111|0000 0000|1.0|
| 1 |011 1111|0000 0000| -1.0|
| * | 000 0000|0000 0001 |±2^(-8) \times 2^(-62)|
| * |000 0000 |1111 1111 |±(2-2^(-8)) \times 2^(-62)|
| * |000 0001 |0000 0000 |±2^(-62) |
| * |111 1110 |1111 1111 |±(2-2^(-8)) \times 2^(63) |
| * |111 1111|0000 0000|±∞|
| * |111 1111|none zero|NaN|





















